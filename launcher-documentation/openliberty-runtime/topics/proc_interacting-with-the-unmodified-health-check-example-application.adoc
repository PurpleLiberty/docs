[id='interacting-with-the-unmodified-health-check-booster_{context}']
[id='interacting-with-the-unmodified-health-check-example-application_{context}']
= Interacting with the unmodified {name-example-health-check} example application

After you deploy the example application, you will have the `{value-name-app}` service running. The `{value-name-app}` service exposes the following REST endpoints:

/api/greeting::
ifdef::built-for-vertx,built-for-nodejs[Returns a JSON containing greeting of `name` parameter (or World as default value).]
ifdef::built-for-spring-boot,built-for-thorntail[Returns a name as a String.]

/api/stop::
Forces the service to become unresponsive as means to simulate a failure.

The following steps demonstrate how to verify the service availability and simulate a failure.
This failure of an available service causes the OpenShift self-healing capabilities to be trigger on the service.

Alternatively, you can use the web interface to perform these steps.

. Use `curl` to execute a `GET` request against the `{value-name-app}` service.
You can also use a browser to do this.
+
--
[source,bash,options="nowrap",subs="attributes+"]
----
$ curl http://{value-name-app}-{value-name-project}.{value-route-openshift-hostname}/api/greeting
----

[source,options="nowrap",subs="attributes+"]
----
{"content":"Hello, World!"}
----
--

. Invoke the `/api/stop` endpoint and verify the availability of the `/api/greeting` endpoint shortly after that.
+
--
Invoking the `/api/stop` endpoint simulates an internal service failure and triggers the OpenShift self-healing capabilities.
When invoking `/api/greeting` after simulating the failure, the service should return
ifndef::built-for-spring-boot[a HTTP status `503`.]
ifdef::built-for-spring-boot[an `Application is not available` page.]

[source,bash,option="nowrap",subs="attributes+"]
----
$ curl http://{value-name-app}-{value-name-project}.{value-route-openshift-hostname}/api/stop
----

ifdef::built-for-vertx,built-for-nodejs[]
[source,option="nowrap",subs="attributes+"]
----
Stopping HTTP server, Bye bye world !
----
endif::[]

(followed by)

[source,bash,option="nowrap",subs="attributes+"]
----
$ curl http://{value-name-app}-{value-name-project}.{value-route-openshift-hostname}/api/greeting
----

// Responses vary wildly among runtimes
ifdef::built-for-vertx,built-for-nodejs[]
[source,option="nowrap",subs="attributes+"]
----
Not online
----
endif::[]

ifdef::built-for-spring-boot[]
----
<html>
  <head>
  ...
  </head>
  <body>
    <div>
      <h1>Application is not available</h1>
      ...
    </div>
  </body>
</html>
----
endif::[]

ifdef::built-for-thorntail[]
----
<html>
  <head><title>Error</title></head>
  <body>503 - Service Unavailable</body>
</html>
----
endif::[]

ifdef::built-for-spring-boot[]
[NOTE]
====
Depending on when OpenShift removes the pod after you invoke the `/api/stop` endpoint, you might initially see a 404 error code.
If continue to invoke the `/api/greeting` endpoint, you will see the `Application is not available` page after OpenShift removes the pod.
====
endif::[]
--

. Use `oc get pods -w` to continuously watch the self-healing capabilities in action.
+
--
While invoking the service failure, you can watch the self-healing capabilities in action on OpenShift console, or with the `oc` client tools.
You should see the number of pods in the `READY` state move to zero (`0/1`) and after a short period (less than one minute) move back up to one (`1/1`).
In addition to that, the `RESTARTS` count increases every time you you invoke the service failure.

[source,bash,options="nowrap",subs="attributes+"]
----
$ oc get pods -w
NAME                           READY     STATUS    RESTARTS   AGE
{value-name-app}-1-26iy7   0/1       Running   5          18m
{value-name-app}-1-26iy7   1/1       Running   5         19m
----
--

. Optional: Use the web interface to invoke the service.
+
--
Alternatively to the interaction using the terminal window, you can use the web interface provided by the service to invoke the different methods and watch the service move through the life cycle phases.

[source,option="nowrap",subs="attributes+"]
----
http://{value-name-app}-{value-name-project}.{value-route-openshift-hostname}
----
--

. Optional: Use the web console to view the log output generated by the application at each stage of the self-healing process.
+
--
. Navigate to your project.
. On the sidebar, click on _Monitoring_.
. In the upper right-hand corner of the screen, click on _Events_ to display the log messages.
. Optional: Click _View Details_ to display a detailed view of the Event log.

The health check application generates the following messages:

[options="header",cols="e,1"]
|===
| Message | Status
| Unhealthy | Readiness probe failed. This message is expected and indicates that the simulated failure of the `/api/greeting` endpoint has been detected and the self-healing process starts.
| Killing | The unavailable Docker container running the service is being killed before being re-created.
| Pulling | Downloading the latest version of docker image to re-create the container.
| Pulled | Docker image downloaded successfully.
| Created | Docker container has been successfully created
| Started | Docker container is ready to handle requests
|===
--
