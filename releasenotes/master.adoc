:context: online
:imagesdir: https://openliberty.io/
= Release Notes for Open Liberty 20.0.0.1 on Red Hat OpenShift Container Platform

== Features

:leveloffset: +1

In Open Liberty 20.0.0.1, you can configure the Social Login feature to use Red Hat OpenShift's OAuth server for authentication. In addition, there is a new MicroProfile Metric to measure CPU time, memory heap and response time.

Give it a try in link:/about/[Open Liberty] 20.0.0.1

If you're interested in what's coming soon in Open Liberty, take a look at our <<previews,current development builds>>. Performance improvements through faster startups with annotation caching, and GraphQL support.

In Open Liberty 20.0.0.1:

* <<SSAA,Support OpenShift OAuth server for authentication and authorization>>
* <<NMM, Monitor the process CPU time (MicroProfile Metrics 2.0)>>
* <<ACC, Faster application startups with Liberty annotation caching>>
* <<JSS, Updated JavaServer Face>>



View the list of fixed bugs in https://github.com/OpenLiberty/open-liberty/issues?utf8=%E2%9C%93&q=label%3Arelease%3A20001+label%3A%22release+bug%22[20.0.0.1]
[#run]

== Run your apps using 20.0.0.1

If you're using link:/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
    <groupId>io.openliberty</groupId>
    <artifactId>openliberty-runtime</artifactId>
    <version>20.0.0.1</version>
    <type>zip</type>
</dependency>
----

Or for link:/guides/gradle-intro.html[Gradle]:

[source,gradle]
----
dependencies {
    libertyRuntime group: 'io.openliberty', name: 'openliberty-runtime', version: '[20.0.0.1,)'
}
----

Or if you're using Docker:

[source]
----
docker pull open-liberty
----
[#SSAA]
== Using Liberty Social Login with Red Hat OpenShift

The Social Login feature `socialLogin-1.0` can now be configured to use OpenShiftâ€™s built-in OAuth server and OAuth Proxy sidecar as authentication providers. The Social Login feature has several pre-configured providers (e.g. Google, GitHub, Facebook) but you can also configure additional providers (e.g. Instagram). OpenShift's OAuth server and OAuth Proxy sidecar can now be configured as additional providers too. The first is a standard OAuth Authorization Code flow, where a web browser accessing an app running in Liberty is redirected to the OpenShift OAuth server to authenticate.
The second is accepting an inbound token from the OpenShift OAuth Proxy sidecar or obtained from an OpenShift API call. This approach requires less cluster-specific configuration.

Most users of this will run Liberty in a pod; however, in the Authorization Code flow, Liberty can run outside the OpenShift cluster. In either mode, an optional JWT can be created for propagation to downstream services.

Using OpenShift as a provider differs slightly from other OAuth providers, it requires a service account token to obtain information about the OAuth tokens.
Once the: client ID, secret, and token have been obtained from OpenShift, Liberty can be configured as shown below.

To enable the feature add it to the `server.xml`

Server configuration to use OpenShift OAuth server:

[source, xml]
----
<server description="social">

  <!-- Enable features -->
  <featureManager>
    <feature>appSecurity-3.0</feature>
    <feature>socialLogin-1.0</feature>
  </featureManager>

<logging traceSpecification="com.ibm.ws.security.*=all=enabled" maxFiles="8" maxFileSize="200"/>

<httpEndpoint  id="defaultHttpEndpoint" host="*" httpPort="8941" httpsPort="8946" > <tcpOptions soReuseAddr="true" /> </httpEndpoint>


  <!-- specify your clientId, clientSecret and userApiToken as liberty variables or environment variables -->
  <oauth2Login id="openshiftLogin"
    scope="user:full"
    clientId="${myclientId}"
    clientSecret="${myclientSecret}"
    authorizationEndpoint="https://oauth-openshift.apps.papains.os.fyre.ibm.com/oauth/authorize"
    tokenEndpoint="https://oauth-openshift.apps.papains.os.fyre.ibm.com/oauth/token"
    userNameAttribute="username"
    groupNameAttribute="groups"
    userApiToken="${serviceAccountToken}"
    userApiType="kube"
    userApi="https://api.papains.os.fyre.ibm.com:6443/apis/authentication.k8s.io/v1/tokenreviews">
  </oauth2Login>

  <keyStore id="defaultKeyStore" password="keyspass" />

  <!-- more application config would go here -->

</server>
----

In the sidecar scenario, the configuration changes to accept an inbound token from the sidecar.
Server configuration to use OAuth proxy sidecar:

[source, xml]
----
<!-- specify your userApiToken as a liberty variable or environment variable -->
  <!-- note that no clientId or clientSecret are needed -->
  <oauth2Login id="openshiftLogin"
    scope="user:full"
    userNameAttribute="username"
    groupNameAttribute="groups"
    userApiToken="${serviceAccountToken}"
    userApiType="kube"
    accessTokenHeaderName="X-Forwarded-Access-Token"
    accessTokenRequired="true"
    userApi="https://kubernetes.default.svc/apis/authentication.k8s.io/v1/tokenreviews">
  </oauth2Login>
----

Use of HTTPS communication requires that the server either have a key signed by a well-known certificate authority, which Liberty can trust automatically or that the server's public key be added to the Liberty trust store. OpenShift does not come with CA-signed keys by default, so the Red Hat OpenShift OAuth server's public key will need to be added. The most convenient way to do this is to specify an environment variable in `server.env`. That identifies the file containing the public key in PEM format. Liberty will read the file and add the key to its trust store.

[source, xml]
----
# server.env

# OAuth sidecar scenario: causes the Kubernetes default certificate that is pre-installed in pods to be added to Liberty trust store.
cert_defaultKeyStore=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt

# OAuth server scenario: causes the public keys from /tmp/trustedcert.pem (obtained seperetly) to be added to Liberty trust store.
cert_defaultKeyStore=/tmp/trustedcert.pem

----

[#NMM]
== Monitor the process CPU time (MicroProfile Metrics 2.0)

A new metric, `processCpuTime,` which returns the CPU time used by the process on which the JVM is running. The MicroProfile Metrics feature provides information monitoring an application, such as CPU time used, memory heap, response time of servlets.

The new `processCpuTime` metric provides a more accurate CPU load percentage on cloud platforms via Grafana. Previously, the CPU load percentage was shown with the metric `processCpuLoad`. However, the load percentage was calculated using the total number of cores allocated to the deployment. If the deployment has a restricted number of cores, the `processCpuLoad` ends up showing a plateau on Grafana when the maximum number of cores is reached. For example, on a deployment with 32 cores allocated but restricted to four cores, the `processCpuLoad` graph shows a plateau at 12.5% when all four cores are used.

The new metric, `processCpuTime,` can be manipulated on Grafana to create a more accurate representation of the CPU being used. `rate(processCpuTime)[1m]` shows the average rate of increase in CPU time over one minute. Dividing this by the total number of CPU cores, we can see a more accurate percentage of the CPU used, taking into account the constraints.

The new `processCpuTime` metric is displayed on the `/metrics` endpoint with the MicroProfile Metrics 2.0 and 2.2 features. On the dashboard, a new panel can be created with the following PromQL query: `(rate(base:cpu_process_cpu_time[2m])/1e9) / base:cpu_available_processors{app=~[[app]]}.` link:https://github.com/OpenLiberty/open-liberty-operator/tree/master/deploy/dashboards/metrics[View full dashboard.]


The following images show that the old metric, `processCpuLoad`, plateaus at 12.5% (4/23), while the new metric, `processCpuTime`, more accurately represents the percentage of CPU used.

image::/img/blog/20001-highcpuload.png[align="center"]
image::/img/blog/20001-lowcpuload.png[align="center"]


With all the machines cores being used and there are no constraints on the processors (32 processors) - The old version and new version display the same data.

image::/img/blog/20001-noconstraints.png[align="center"]

== Faster application startups with Liberty annotation caching

Application startup times have been made faster by adding cache capabilities `annotation caching` to core class and annotation scanning function. Depending on application characteristics, startup times are reduced by 10% to more than 50%. Applications with many jar files, or which use CDI or JAX-RS function, see the best improvements:

image::/img/blog/190011-annotationcaching-graph.png[align="center"]

Good news! Annotation caching is enabled by default.

Annotation cache data is stored in the server workarea. Cache of application class data is cleared when performing a clean server start (starting the server with the `--clean` option). In normal operations, the clearing of cache data is not necessary, since the cache automatically regenerates cache data for changed application classes.

In container environments, for annotation caching to be effective, the server image must be "warmed" when the container image is created. Warming the server an be done by starting and stopping the server during the container build. Warming the image moves the annotation scan into the container build meaning you get optimal startup on the container deployment. Using the configure.sh file in the base open-liberty docker images causes the server to be started and stopped during the container build.

[#JSS]
== Bug Fixes in the JavaServer Faces 2.3

JavaServer Faces 2.3 contains a new feature to get bug fixes that are in Apache MyFaces 2.3.6. The jsf-2.3 feature pulls in the Apache MyFaces implementation and integrates it into the Liberty runtime.

The Apache MyFaces 2.3.6 release contains bug fixes. View link:https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=10600&version=12346352[the release notes for more information.]

To use the JSF 2.3, enable the `jsf-2.3` feature to leverage the latest Apache MyFaces 2.3. release For more information about the JavaServer Feature, view the link:https://myfaces.apache.org/[Apache website.]


:leveloffset!:

== Resolved issues

See the https://github.com/OpenLiberty/open-liberty/issues?utf8=%E2%9C%93&q=label%3A%22release+bug%22+label%3Arelease%3A20001+is%3Aclosed+[Open Liberty 20.0.0.1 issues that were resolved for this release].

== Fixed CVEs

For a list of CVEs that were fixed in Open Liberty 20.0.0.1, see https://openliberty.io/docs/ref/general/#security-vulnerabilities.html[security vulnerabilities].

== Known issues

See the https://github.com/OpenLiberty/open-liberty/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22release+bug%22+created%3A2019-12-06..2020-1-16+-label%3Arelease%3A190012+[list of issues that were found but not fixed during the development of 20.0.0.1].
