Unresolved directive in master-remote.adoc - include::attributes.adoc[]

= Open Liberty Runtime Guide
:context: open-liberty

:leveloffset: +1

// Module included in the following assemblies:
//
//

[id="what-is-openliberty-{context}"]
= What is Open Liberty

Open Liberty is a lightweight Java runtime for building cloud-native applications and microservices.

With Open Liberty, it's easy to add and remove modular features from the latest versions of Jakarta EE and Eclipse MicroProfile. This modular structure simplifies microservice development, enabling you to run Just enough Application Server to support the features that your application needs. Furthermore, with Open Liberty zero migration architecture, you can upgrade to the latest version with minimal impact to your current applications and configurations. Open Liberty is compatible with the Jakarta EE 8 Full Platform and Web Profile specifications and with MicroProfile 3.0. For more information, see the link:https://openliberty.io/[Open Liberty website]. For the latest updates about Open Liberty features and capabilities, see the link:https://openliberty.io/blog/[Open Liberty blog] and https://openliberty.io/docs/[Open Liberty docs].

Open Liberty is one of the Java runtimes available on OpenShift, and support is provided as part of a Red Hat subscription. Run Open Liberty on OpenShift to build and deploy cloud-native applications with the benefits of the OpenShift platform. For more information about using Open Liberty with OpenShift, see link:https://openliberty.io/guides/cloud-openshift.html[Deploying microservices to OpenShift].

== Open Liberty Versioning

Traditional versioning follows some variation of the major.minor.micro scheme, where significant new function is only delivered in a major release. These major releases contain key new capabilities, but they also make behavior changes that require application migration and significant regression testing to adopt. As a result, multiple major versions are supported at any one time. The modular feature architecture of Open Liberty, in combination with zero migration, allows the delivery of new function incrementally, without following a major.minor.micro versioning scheme.

Instead of major releases, each Open Liberty release is considered a micro, or patch release. These patch releases follow a yy.0.0.nn version scheme. The first two digits indicate the year of release and the last two digits indicate the number of the release within that year. Even though the first set of digits changes each year, the releases are of equal standing. For example, the difference between 20.0.0.1 (the first release of 2020) and 19.0.0.12 (the last release of 2019) is identical to the difference between 19.0.0.10 and 19.0.0.11.

The lack of major release streams is unusual for server runtimes, but is common for desktop and mobile applications. Some publication systems expect software to have a major version. As a result, in cases where a major version is needed, the year of publication is used as a stand-in. For example, Open Liberty documentation that is published for this guide in 2019 uses the year 2019 as the version number. However, this documentation is as applicable to releases in 2020 as it is to releases in 2019.

:leveloffset!:

:leveloffset: +1

// Module included in the following assemblies:
//
//

[id="packaging-and-deploying-applications-{context}"]
= Packaging and Deploying applications

You can package everything you need to run your application in a container image and use containers to deploy it in different environments. When you run Open Liberty applications on OpenShift, you combine the most flexible server runtime available to Java developers with a streamlined DevOps process and an intuitive development pipeline.

For more information, see link:https://www.openliberty.io/guides/cloud-openshift.html[Deploying microservices to OpenShift].

To learn how to containerize and run your microservices with Open Liberty, see link:https://openliberty.io/guides/containerize.html[Containerizing microservices].

Open Liberty supports all MicroProfile and Java EE APIs and deploys to every major cloud platform. To get started with Open Liberty, learn how to to run and update a simple REST microservice with link:https://openliberty.io/guides/getting-started.html[Packaging and deploying applications].




.Additional resources
* link:https://openliberty.io/guides/kubernetes-intro.html[Deploying microservices to Kubernetes]

:leveloffset!:

:leveloffset: +1

= Feature overview
:projectName: Open Liberty
:page-layout: feature
:page-type: overview

Features are the discrete units of functionality by which you control the pieces of the runtime environment that are loaded into a particular server. By adding or removing features from your server configuration, you can control what functions the server can perform. Features provide the programming models and services that applications require. You can specify any feature in the server configuration files. Some features include other features within them, and the same feature might be included in one or more other features.

When the server is started, the JVM is launched and control is passed to the Open Liberty kernel. The configuration is loaded as described in the link:https://www.openliberty.io/docs/ref/config/[Server configuration overview]. When the configuration is parsed, the feature manager gains control and processes the `featureManager` configuration to load the requested features into the server and start the required components. Finally, the applications are started. When the configuration is changed, the feature manager reevaluates the code that is required for the newly requested features by starting and stopping parts of the runtime as necessary without restarting the server. Changes to applications are processed in a similar way.

== Using features
Features are specified in the system configuration files that are the `server.xml` file and any other included files. The feature manager is configured by using the `featureManager` element in the `server.xml` file. Each feature that is required is configured by using the `feature` element. The following example configures the `servlet-4.0` and `jdbc-4.3` features:

[source,xml]
----
<server>
  <featureManager>
    <feature>servlet-4.0</feature>
    <feature>jdbc-4.3</feature>
  </featureManager>
</server>
----

The runtime contains default configuration settings so that the configuration you need to specify is kept to a minimum. You specify the features that you need, along with any additions or overrides to the default settings, in the `server.xml` file. For details about the server configuration, see the link:/docs/ref/config/[Server configuration overview].

== Zero-migration
With the Open Liberty zero-migration architecture, you can move to the latest version of Open Liberty with minimal impact to your current applications and configurations. Zero-migration architecture means that you can use existing, unmodified configuration and application files with an updated version of the Open Liberty runtime environment without unwanted or unexpected change in behavior.

With the use of pluggable features in the Open Liberty runtime environment, your existing APIs and behaviors are supported in new product versions, and new APIs and behaviors are added in new features. For example, both the Servlet 3.1 and 4.0 specifications are supported. Changes in API behavior only happen in new feature versions, so you can choose the appropriate feature version for your application. These versioned features continue to be supported across Open Liberty updates.

If you continue to use the same feature version, you never need to migrate your application. For example, if your application uses Servlet 3.1, the Open Liberty server that runs the application must have the `servlet-3.1` feature. You can update Open Liberty and continue to use the `servlet-3.1` feature indefinitely, regardless of how many other Servlet specification levels are supported. You need to migrate your applications only if you choose to use the `servlet-4.0` feature instead.

== Combining features
If you try to configure a server to have different versions of a feature, an error is reported because Open Liberty doesn't support combining different versions of the same feature. This means that most Open Liberty features are singleton features. A singleton feature is a feature for which you can configure only one version for use in a server.

If you have applications that need different versions of the singleton feature, you must deploy them in different servers. If your server configuration includes multiple versions of a singleton feature, either through direct configuration in the `server.xml` file, or through feature dependencies, that configuration is in error and neither version of that feature is loaded. To resolve this problem, ensure that the configured features all specify, or tolerate, the same version of that singleton feature. If you have hard requirements on both feature versions, you must move some of your applications to a different server.

Liberty doesn't support combining features from both Java EE 7 and Java EE 8, except when the Java EE 7 and Java EE 8 specifications share a component specification version. If you combine Java EE 7 and Java EE 8 features in a server configuration, the server reports errors at startup.

The following features are included in both Java EE 7 and Java EE 8:

* link:https://www.openliberty.io/docs/ref/feature/#appClientSupport-1.0.html[appClientSupport-1.0]
* link:https://www.openliberty.io/docs/ref/feature/#batch-1.0.html[batch-1.0]
* link:https://www.openliberty.io/docs/ref/feature/#concurrent-1.0.html[concurrent-1.0]
* link:https://www.openliberty.io/docs/ref/feature/#ejb-3.2.html[ejb-3.2]
* link:https://www.openliberty.io/docs/ref/feature/#j2eeManagement-1.1.html[j2eeManagement-1.1]
* link:https://www.openliberty.io/docs/ref/feature/#jacc-1.5.html[jacc-1.5]
* link:https://www.openliberty.io/docs/ref/feature/#jaxws-2.2.html[jaxws-2.2]
* link:https://www.openliberty.io/docs/ref/feature/#jca-1.7.html[jca-1.7]
* link:https://www.openliberty.io/docs/ref/feature/#jcaInboundSecurity-1.0.html[jcaInboundSecurity-1.0]
* link:https://www.openliberty.io/docs/ref/feature/#jdbc-4.2.html[jdbc-4.2]
* link:https://www.openliberty.io/docs/ref/feature/#jdbc-4.3.html[jdbc-4.3]
* link:https://www.openliberty.io/docs/ref/feature/#jms-2.0.html[jms-2.0]
* link:https://www.openliberty.io/docs/ref/feature/#wasJmsClient-2.0.html[wasJmsClient-2.0]
* link:https://www.openliberty.io/docs/ref/feature/#wasJmsSecurity-1.0.html[wasJmsSecurity-1.0]
* link:https://www.openliberty.io/docs/ref/feature/#wasJmsServer-1.0.html[wasJmsServer-1.0]

For a complete list of features that support Java EE 7, see the link:https://www.openliberty.io/docs/ref/feature/#javaee-7.0.html[javaee-7.0] feature. For a complete list of features that support Java EE 8, see the link:https://www.openliberty.io/docs/ref/feature/#javaee-8.0.html[javaee-8.0] feature.

== Superseded features
If a feature is superseded, a new feature or a combination of features might provide an advantage over the superseded feature. The new feature or features might not completely replace the function of the superseded feature, so you must consider your scenario before you decide whether to change your configuration. Superseded features remain supported and valid for use in your configuration, but you might be able to improve your configuration by using the newer features.

Occasionally, a feature that includes other features is superseded by a new version of the feature that does not include all those features. The features that are not included in the new version are considered to be separated. If your application depends on the functions of a separated feature, you must explicitly add the separated feature to your configuration.

The following table lists the Open Liberty features that are superseded:

[%header,cols=3*]
|===

|Superseded feature
|Superseding feature
|Dependent feature removed

|`appSecurity-1.0`
|`appSecurity-2.0`
|The link:https://www.openliberty.io/docs/ref/config/#ldapRegistry.html[ldapRegistry] and the `servlet-3.0` feature were removed from the definition of the `appSecurity-2.0` feature.

|`jmsMdb-3.2`
|`jms-2.0` and `mdb-3.2`
|Together, the `jms-2.0` and `mdb-3.2` features provide the same function as the `jmsMdb-3.2` feature.

|`ssl-1.0`
|`transportSecurity-1.0`
|The `ssl-1.0` and `transportSecurity-1.0` features are functionally equivalent. However, `ssl-1.0` implies that an insecure network protocol is used, so `transportSecurity-1.0` supersedes it.

|===

:leveloffset!:

:leveloffset: +1

= Server configuration overview
:projectName: Open Liberty
:page-layout: config
:page-type: overview

The {projectName} server config is made up of one mandatory file, the `server.xml` file, and a set of optional files.
The `server.xml` file must be well-formed XML and the root element must be `server`.
When the `server.xml` file is processed, any elements or attributes that are not understood are ignored.

This example `server.xml` file configures the server to do the following things:

[source,xml]
----
<server description="new server">
    <featureManager>
        <feature>jsp-2.3</feature> // <!--1-->
    </featureManager>
    <httpEndpoint id="defaultHttpEndpoint"
                  httpPort="9080" // <!--2-->
                  httpsPort="9443" />
    <applicationManager autoExpand="true" /> // <!--3-->
</server>
----
<1> Support the JavaServer Pages 2.3 feature
<2> Listen to incoming traffic to `localhost` on port `9080`
<3> Automatically expand WAR files when they are deployed

The term _server config_ can be used to refer to all of the files that make up the server config, or specifically to the config that's in the XML files.
If it's not clear in context, the term _server XML config_ might be used to refer to the config in the XML files.

== Config files

The server config files are processed in the following order:

. <<server-env,`server.env`>> - Environment variables are specified in this file.
. <<jvm-options,`jvm.options`>> - JVM options are set in this file.
. <<bootstrap-properties,`bootstrap.properties`>> - This file influences the startup of the {projectName} server.
. <<server-xml,`server.xml`>> - This mandatory file specifies the server config and features.

[#server-env]
=== server.env
The `server.env` files are optional.
These files are read by the `bin/server` shell script and specify environment variables that are primarily used to influence the behavior of the `bin/server` script.
`server.env` files are read from the following locations in order:

. `${wlp.install.dir}/etc/`
. `${wlp.user.dir}/shared/`
. `${server.config.dir}/`

If the same property is set in multiple locations, then the last value found is used.

The most common use of these files is to set the following environment variables:

* `JAVA_HOME` - Indicates which JVM to use.
If this is not set, the system default is used.
* `WLP_USER_DIR` - Indicates the location of the `usr` directory that contains the server config.
This can only be set in the `etc/server.env` file because the other locations are relative to the `usr` directory.
* `WLP_OUTPUT_DIR` - Indicates where the server writes files to.
By default, the server writes to the directory structure that the config is read from.
However, in some secure profiles the server config needs to be read-only so the server must write files to another location.

The `server.env` file is in `KEY=value` format, as shown in the following example:

[source,properties]
----
JAVA_HOME=/opt/ibm/java
WLP_USER_DIR=/opt/wlp-usr
----

Key values must not contain spaces.
The values are interpreted literally so you don’t need to escape special characters, such as spaces.
These files don't support variable substitution.

[#jvm-options]
=== jvm.options
The `jvm.options` files are optional.
These files are read by the `bin/server` shell script to determine what options to use when the JVM is launched for {projectName}.
`jvm.options` files are read from the following locations in order:

. `${wlp.user.dir}/shared/jvm.options`
. `${server.config.dir}/configDropins/defaults/`
. `${server.config.dir}/`
. `${server.config.dir}/configDropins/overrides/`

If no `jvm.options` files exist in these locations, then the server script looks for the file in `${wlp.install.dir}/etc`, if such a directory exists.

Common uses of `jvm.options` files include:

* Setting JVM memory limits
* Enabling Java Agents that are provided by monitoring products
* Setting Java System Properties

The `jvm.options` file format uses one line per JVM option, as shown in the following example:

[source,properties]
----
-Xmx512m
-Dmy.system.prop=This is the value.
----

You don’t need to escape special characters, such as spaces.
Options are read and provided to the JVM in order.
If you provide multiple options, then they are all seen by the JVM.
These files do not support variable substitution.

[#bootstrap-properties]
=== bootstrap.properties
The `bootstrap.properties` file is optional.
This file is read during {projectName} bootstrap to provide config for the earliest stages of the server startup.
It is read by the server earlier than the `server.xml` file so it can affect the startup and behavior of the {projectName} kernel from the start.
The `bootstrap.properties` file is a simple Java properties file and is located in `${server.config.dir}`.
A common use of the `bootstrap.properties` file is to configure logging because it can affect logging behavior before the `server.xml` file is read.

The `bootstrap.properties` file supports a special optional property, `bootstrap.include`, which specifies another properties file to also be read during the bootstrap stage.
For example, this `boostrap.include` file can contain a common set of bootstrap properties for multiple servers to use.
Set the `bootstrap.include` file to an absolute or relative file path.

[#server-xml]
=== server.xml
The most important and only required config file is the `server.xml` file.
The `server.xml` file must be well-formed XML and the root element must be `server`.
The exact elements that are supported by a server depend on which features are configured, and any unknown config is ignored.

{projectName} uses a principle of configuration by exception, which allows for succinct config files.
The runtime environment operates from a set of built-in config default settings.
You only specify config that overrides those default settings.

Server config files are read from the following locations in order:

. `${server.config.dir}/configDropins/defaults/`
. `${server.config.dir}/server.xml`
. `${server.config.dir}/configDropins/overrides/`

The `${server.config.dir}/server.xml` file must be present, but the other files are optional.
You can flexibly compose config by dropping server-formatted XML files into directories.
Files are read in alphabetical order in each of the two `configDropins` directories.

== Variable substitution
You can use variables to parameterize the server config.
To resolve variable references to their values, the following sources are consulted in order:

. `server.xml` default variable values
. environment variables
. `bootstrap.properties`
. Java system properties
. `server.xml` config
. variables declared on the command line

Variables are referenced by using the `${variableName}` syntax.
Specify variables in the server config, as shown in the following example:

[source,xml]
----
<variable name="variableName" value="some.value" />
----

Default values, which are specified in the `server.xml` file, are used only if no other value is specified:

[source,xml]
----
<variable name="variableName" defaultValue="some.default.value" />
----

You can also specify variables at startup from the command line.
If you do, the variables that are specified on the command line override all other sources of variables and can't be changed after the server starts.

Environment variables can be accessed as variables.
As of version 19.0.0.3, you can reference the environment variable name directly.
If the variable cannot be resolved as specified, the `server.xml` file looks for the following variations on the environment variable name:

* Replace all non-alphanumeric characters with the underscore character (`_`)
* Change all characters to uppercase

For example, if you enter `${my.env.var}` in the `server.xml` file, it looks for environment variables with the following names:

. my.env.var
. my_env_var
. MY_ENV_VAR

For versions 19.0.0.3 and earlier, you can access environment variables by adding `env.` to the start of the environment variable name, as shown in the following example:

[source,xml]
----
<httpEndpoint id="defaultHttpEndpoint"
              host="${env.HOST}"
              httpPort="9080" />
----

Variable values are always interpreted as a string with simple type conversion.
Therefore, a list of ports (such as `80,443`) might be interpreted as a single string rather than as two port numbers.
You can force the variable substitution to split on the `,` by using a `list` function, as shown in the following example:

[source,xml]
----
<mongo ports="${list(mongoPorts)}" hosts="${list(mongoHosts)}" />
----

Simple arithmetic is supported for variables with integer values.
The left and right sides of the operator can be either a variable or a number.
The operator can be `+`, `-`, `*`, or `/`, as shown in the following example:

[source,xml]
----
<variable name="one" value="1" />
<variable name="two" value="${one+1}" />
<variable name="three" value="${one+two}" />
<variable name="six" value="${two*three}" />
<variable name="five" value="${six-one}" />
<variable name="threeagain" value="${six/two}" />
----

There are a number of predefined variables:

* `wlp.install.dir` - the directory where the {projectName} runtime is installed.
* `wlp.server.name` - the name of the server.
* `wlp.user.dir` - the directory of the `usr` folder.
The default is `${wlp.install.dir}/usr`.
* `shared.app.dir` - the directory of shared applications.
The default is `${wlp.user.dir}/shared/apps`.
* `shared.config.dir` - the directory of shared config files.
The default is `${wlp.user.dir}/shared/config`.
* `shared.resource.dir` - the directory of shared resource files.
The default is `${wlp.user.dir}/shared/resources`.
* `server.config.dir` - the directory where the server config is stored.
The default is `${wlp.user.dir}/servers/${wlp.server.name}`.
* `server.output.dir` - the directory where the server writes the workarea, logs, and other runtime-generated files.
The default is `${server.config.dir}`.

== Config merging
Since the config can consist of multiple files, it is possible that two files provide the same config.
In these situations, the server config is merged according to a set of simple rules.
In {projectName}, config is separated into singleton and factory config, each of which has its own rules for merging.
Singleton config is used to configure a single element (for example, logging).
Factory config is used to configure multiple entities, such as an entire application or data source.

=== Merging singleton config
For singleton config elements that are specified more than once, the config is merged.
If two elements exist with different attributes, both attributes are used.
For example:

[source,xml]
----
<server>
    <logging a="true" />
    <logging b="false" />
</server>
----

is treated as:

[source,xml]
----
<server>
    <logging a="true" b="false" />
</server>
----

If the same attribute is specified twice, then the last instance takes precedence.
For example:

[source,xml]
----
<server>
    <logging b="false" />
</server>
----

is treated as:

[source,xml]
----
<server>
    <logging a="true" b="false" />
</server>
----

Config is sometimes provided by using child elements that take text.
In these cases, the config is merged by using all of the values specified.
The most common scenario is configuring features.
For example:

[source,xml]
----
<server>
    <featureManager>
        <feature>servlet-4.0</feature>
    </featureManager>
    <featureManager>
        <feature>restConnector-2.0</feature>
    </featureManager>
</server>
----

is treated as:

[source,xml]
----
<server>
    <featureManager>
        <feature>servlet-4.0</feature>
        <feature>restConnector-2.0</feature>
    </featureManager>
</server>
----

=== Merging factory config
Factory config merges use the same rules as singleton config except elements are not automatically merged just because the element names match.
With factory config, it is valid to configure the same element and mean two different logical objects.
Therefore, each element is assumed to configure a distinct object.
If a single logical object is configured by two elements, the `id` attribute must be set on each element to indicate they are the same thing.
Variable substitution on an `id` attribute is not supported.

The following example configures two applications.
The first application is `myapp.war`, which has a context root of `myawesomeapp`. The other application is `myapp2.war`, which has `myapp2` as the context root:

[source,xml]
----
<server>
    <webApplication id="app1" location="myapp.war" />
    <webApplication location="myapp2.war" />
    <webApplication id="app1" contextRoot="/myawesomeapp" />
</server>
----

== Include processing

In addition to the default locations, additional config files can be brought in by using the `include` element.
When a server config file contains an include reference to another file, the server processes the contents of the referenced file as if they were included inline in place of the `include` element.
In the following example, the server processes the contents of the `other.xml` file before it processes the contents of the `other2.xml` file:

[source,xml]
----
<server>
    <include location="other.xml" />
    <include location="other2.xml" />
</server>
----

By default, the include file must exist.
If the include file might not be present, set the `optional` attribute to `true`, as shown in the following example:

[source,xml]
----
<server>
    <include location="other.xml" optional="true" />
</server>
----

When you include a file, you can specify the `onConflict` attribute to change the normal merge rules.
You can set the value of the `onConflict` attribute to `IGNORE` or `REPLACE` any conflicting config:

[source,xml]
----
<server>
    <include location="other.xml" onConflict="IGNORE" />
    <include location="other2.xml" onConflict="REPLACE" />
</server>
----

You can set the `location` attribute to a relative or absolute file path, or to an HTTP URL.


== Config references
Most config in {projectName} is self-contained but it is often useful to share config.
For example, the JDBC driver config might be shared by multiple data sources.
You can refer to any factory config element that is defined as a direct child of the `server` element.

A reference to config always uses the `id` attribute of the element that is being referenced.
The config element that makes the reference uses an attribute that always ends with `Ref`, as shown in the following example:

[source,xml]
----
<server>
  <dataSource jndiName="jdbc/fred" jdbcDriverRef="myDriver" />
  <jdbcDriver id="myDriver" />
</server>
----

== Dynamic updates
The server monitors the server XML config for updates and dynamically reloads when changes are detected.
Changes to non-XML files (`server.env`, `bootstrap.properties`, and `jvm.options`) are not dynamic because they are only read at startup.
Any server XML config file on the local disk is monitored for updates every 500ms. You can configure the frequency of XML config file monitoring.
For example, to configure the server to monitor every 10 minutes, specify:

[source,xml]
----
<config monitorInterval="10m" />
----

To disable file system polling and reload only when an MBean is notified, specify:

[source,xml]
----
<config updateTrigger="mbean" />
----

== Log messages
When the server runs, it might output log messages that reference config.
The references in the log use an XPath-like structure to specify config elements.
The element name is given with the value of the `id` attribute inside square brackets.
If no `id` is specified in the server config, an `id` is automatically generated.
Based on the following server XML config example, the `dataStore` element and the child `dataSource` are identified in the logs as `dataStore[myDS]` and `dataStore[myDS]/dataSource[default-0]`.

[source,xml]
----
<server>
    <dataStore id="myDS">
        <dataSource />
    </dataStore>
</server>
----

:leveloffset!:

:leveloffset: +1

// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description: When you run Open Liberty in development mode, you can rapidly code, deploy, test, and debug applications directly in your IDE or text editor.
:seo-title: Development mode
:seo-description: When you run Open Liberty in development mode, you can rapidly code, deploy, test, and debug applications directly in your IDE or text editor.
:page-layout: general-reference
:page-type: general
= Development mode

When you run Open Liberty in development mode, you can rapidly code, deploy, test, and debug applications directly from your integrated development environment (IDE) or text editor. You can enable development mode to work with either Maven or Gradle build automation tools.

With development mode, you can quickly iterate on changes to your code and get immediate feedback from on-demand or automatic unit and integration tests. You can also attach a debugger to step through your code at any time.
Development mode is available as a goal of link:https://github.com/OpenLiberty/ci.maven[the Open Liberty Maven plug-in] or as a task of https://github.com/OpenLiberty/ci.gradle[the Liberty Gradle plug-in].
It integrates a set of capabilities for Open Liberty so that you can edit and monitor your application in real time, without restarting your running server.
Development mode addresses three primary focus areas: deploying changes, running tests, and debugging.

== Run Open Liberty in development mode

You can use development mode through either the Open Liberty Maven plug-in or the Open Liberty Gradle plug-in. To use development mode, link:https://github.com/OpenLiberty/ci.maven#configuration[enable the Open Liberty Maven plug-in] or link:https://github.com/OpenLiberty/ci.gradle#usage[the Open Liberty Gradle plug-in] and run one of the following commands:

Maven: `mvn liberty:dev`

Gradle: `gradle libertyDev`

=== Detect, recompile, and deploy code changes

Development mode can automatically detect, recompile, and deploy code changes whenever you save a new change in your IDE or text editor. Development mode automatically detects the following changes to your application source:

- Java source file and test file changes
- Resource file changes
- Configuration directory and configuration file changes
- New dependency additions to your `pom.xml` file for Maven users or `build.gradle` file for Gradle users
- New feature additions in the Open Liberty server configuration

Resource file, configuration file, and configuration directory changes are copied into your target directory.
New dependencies in your `pom.xml` file or `build.gradle` file are added to your class path.
New features are installed and started.

Some changes, such as adding certain configuration directories or files, do not take effect until you restart development mode.
To enable these changes, restart development mode when prompted.
To restart, first exit development mode by pressing `CTRL+C`, or by typing `q` and pressing `Enter`.
Then, run the `mvn liberty:dev` command or the `gradle libertyDev` command to restart.
After the server restarts, the changes are detected, recompiled, and picked up by the running server.

You can configure how development mode handles changes to your code by specifying parameters when you start development mode.
For more information about configuration parameters, see link:https://github.com/OpenLiberty/ci.maven/blob/master/docs/dev.md#dev[the dev goal of the Open Liberty Maven plug-in] or link:https://github.com/OpenLiberty/ci.gradle/blob/master/docs/libertyDev.md#libertydev-task[the libertyDev task of the Open Liberty Gradle plug-in].

=== Run unit and integration tests on demand

You can run unit and integration tests on demand by pressing `Enter` in the command window where development mode is running.
Development mode runs the unit tests and integration tests that are configured for your project.
If you add a test to your project, development mode compiles and includes it the next time that you run tests.

You can get immediate feedback on your changes by configuring development mode to run hot tests.
Hot tests are unit or integration tests that run automatically whenever you start development mode or make a code change.
To configure hot testing, specify the hot test parameter when you start development mode, as shown in the following examples:

Maven: `mvn liberty:dev -DhotTests`

Gradle: `gradle libertyDev --hotTests`

You can also add parameters to specify whether to skip tests.
For Maven, you can add parameters to skip unit tests, skip integration tests, or skip all tests. For Gradle, you can add a parameter to skip all tests.
For more information about configuration parameters, see link:https://github.com/OpenLiberty/ci.maven/blob/master/docs/dev.md#dev[the dev goal of the Open Liberty Maven plug-in] or link:https://github.com/OpenLiberty/ci.gradle/blob/master/docs/libertyDev.md#libertydev-task[the libertyDev task of the Open Liberty Gradle plug-in].

=== Attach a debugger to the running server

You can attach a debugger to the running server to step through your code at any time.
You can specify breakpoints in your source code to locally debug different parts of your application.
The default port for debugging is `7777`.
If the default port is not available, development mode selects a random port to use as the debug port.

=== VS Code extension for development mode

With the link:https://marketplace.visualstudio.com/items?itemName=Open-Liberty.liberty-dev-vscode-ext[Open Liberty Tools VS Code extension], you can start development mode, make dynamic code changes, run tests, and debug your application, all without leaving the VS Code editor.
After you install the extension and enable either the Maven or Gradle plug-in, you can select your project under the Liberty Dev Dashboard in the VS Code side bar.
You can access development mode functions by right-clicking your project name and selecting a command from the menu.


== Where to next

- Try out development mode for yourself with link:https://github.com/OpenLiberty/demo-devmode[the demo-devmode sample project] and the guide to link:/guides/getting-started.html[Packaging and deploying applications].

== See also

- View command examples, explanations of available development mode parameters, and more in link:https://github.com/OpenLiberty/ci.maven/blob/master/docs/dev.md#dev[the dev goal of the Open Liberty Maven plug-in] and link:https://github.com/OpenLiberty/ci.gradle/blob/master/docs/libertyDev.md#libertydev-task[the libertyDev task of the Open Liberty Gradle plug-in].

:leveloffset!:

:leveloffset: +1

// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description: Open Liberty provides a self-tuning algorithm that controls the size of its thread pool. For most applications that run on Open Liberty, it is not necessary to tune the size of the thread pool.
:page-layout: general-reference
:seo-title: The Open Liberty self-tuning thread pool
:seo-description: Open Liberty provides a self-tuning algorithm that controls the size of its thread pool. For most applications that run on Open Liberty, it is not necessary to tune the size of the thread pool.
:page-layout: general-reference
:page-type: general
= Automated thread pool tuning

Open Liberty provides a self-tuning algorithm that controls the size of its thread pool.
For most applications that run on Open Liberty, you do not need to tune the size of the thread pool.

All the application code in Open Liberty runs in a single thread pool that is called the default executor.
The size of this pool is set by a self-tuning controller, which can manage a wide range of workloads.
The default executor pool is the set of threads where your application code runs.
Open Liberty uses other threads for tasks like serving the OSGi framework, collecting JVM garbage, and providing Java NIO transport functions.
However, these threads are not directly relevant to application performance and most of them are not configurable.

== Thread pool tuning behavior
The Open Liberty thread pool self-tuning process runs every 1.5 seconds.
The thread pool controller maintains a set of data about the thread pool performance from the time the server started.
The throughput is determined by the number of tasks that are completed by the controller each cycle.
The controller records the throughput for the various pool sizes that were previously tried.
This historical throughput data is then compared to throughput for the current cycle to decide the optimal pool size.
At each cycle, the pool size can be incrementally increased or decreased, or left unchanged.

In some cases, no historical data is available to guide the decision.
For example, if the pool is growing with each cycle and the current cycle is at the largest size so far, no data exists about throughput for larger pool sizes.
In such a case, the controller decides at random whether to increase the size of the pool.
Then, it readjusts for the next cycle based on the results of that decision.
This process is analogous to a human thread pool tuner who tries various thread pool sizes to see how they perform and decides on an optimal value for the configuration and workload.

During each 1.5-second cycle, the thread pool controller runs through the following self-tuning operations:

. Wakes up and checks whether the threads in the pool are hung. If tasks are in the queue and no tasks were completed in the previous cycle, the controller considers the threads to be hung. In this case, the controller increases the thread pool size as specified by settings and skips to step 5.

. Updates the historical data set with the number of tasks that completed in the most recent controller cycle. Performance is recorded as a weighted moving average for each pool size. This performance reflects historical results but adjusts quickly to changing workload characteristics.

. Uses historical data to predict whether performance would be better at smaller or larger pool sizes. If no historical data exists for the smaller or larger pool size, the thread pool controller decides whether to increase or shrink the size of the pool.

. Increases or decreases the pool size within the bounds that are specified in settings, or leaves it unchanged, based on predicted performance.

. Goes back to sleep.

Various factors other than the thread pool size can affect throughput in the Open Liberty server.
The relationship between pool size and observed throughput is not perfectly smooth or continuous.
Therefore, to improve the predictions that are derived from the historical throughput data, the controller considers not just the closest larger and smaller pool size performance, but also includes several increments in each direction.

=== Hang resolution

In some application scenarios, all the threads in the pool can become blocked by tasks that must wait for other work to finish before they can run.
In these cases, the server can become hung at a certain pool size.
To resolve this situation, the thread pool controller enters a hang resolution mode.

Hang resolution adds threads to the pool to allow the server to resume normal operation.
Hang resolution also shortens the controller cycle duration to break the deadlock quickly.

When the controller observes that tasks are being completed again, normal operation resumes.
The controller cycle returns to its normal duration, and pool size is adjusted based on the usual throughput criteria.

== Manual thread pool tuning
In most environments, configurations, and workloads, the Open Liberty thread pool does not require manual configuration or tuning.
The thread pool self-tunes to determine how many threads are needed to provide optimal server throughput.
The thread pool controller continually adjusts the number of threads in the pool within the defined bounds for coreThreads and maxThreads.
However, in some situations, setting the `coreThreads` or `maxThreads` attributes might be necessary.
The following sections describe these attributes provide examples of conditions under which they might need to be manually tuned.

* `coreThreads` +
This attribute specifies the minimum number of threads in the pool. The  minimum value for this attribute is 4.
Open Liberty creates a new thread for each piece of offered work until the number of threads equals the value of this attribute.
If the `coreThreads` attribute is not configured, it defaults to a multiple of the number of hardware threads available to the Open Liberty process.
+
If Open Liberty is running in a shared environment, the thread pool controller cannot account for other processes with which it is sharing the available CPUs.
In these cases, the default value of the `coreThreads` attribute might cause Open Liberty to create more threads than is optimal, considering the other processes that are competing for CPU resources.
In this situation, you can limit the `coreThreads` attribute to a value that reflects only the proportion of the CPU resources that Open Liberty needs to run.

* `maxThreads` +
This attribute specifies the maximum number of threads in the pool.
The default value is -1, which is equal to `MAX_INT`, or effectively unlimited.
+
Some environments set a hard limit on the number of threads that a process can create.
Currently, Open Liberty has no way to know whether such a cap applies, or what the value is.
If Open Liberty is running in a thread-limited environment, the operator can configure the `maxThreads` attribute to an acceptable value.

The Open Liberty thread pool controller is designed to handle a wide range of workloads and configurations. In some edge cases, you might need to adjust the `coreThreads` and `maxThreads` attributes. However, try the default behavior first to make sure you need to make adjustments.

== See also

For more information, see link:/docs/ref/config/#executor.html[Executor Management].

:leveloffset!:

:leveloffset: +1

// Copyright (c) 2013, 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-layout: general-reference
:page-type: general
= Logging and tracing

Open Liberty has a unified logging component that handles messages that are written by applications and the runtime, and provides First Failure Data Capture (FFDC) capability. Logging data written by applications using `System.out`, `System.err`, or `java.util.logging.Logger` are combined into the server logs.

There are three primary log files for a server:

- `console.log` - This file is created by the `server start` command. It contains the redirected standard output and standard error streams from the JVM process. This console output is intended for direct human consumption so lacks some information useful for automated log analysis.
- `messages.log` - This file contains all messages that are written or captured by the logging component. All messages that are written to this file contain additional information such as the message time stamp and the ID of the thread that wrote the message. This file is suitable for automated log analysis. This file does not contain messages that are written directly by the JVM process.
- `trace.log` - This file contains all messages that are written or captured by the logging component and any additional trace. This file is created only if you enable additional trace. This file does not contain messages that are written directly by the JVM process.

== Logging configuration
The logging component can be controlled through the server configuration. The logging component can be fully configured in `server.xml` using the `logging` element. However, logging is initialized before `server.xml` has been processed so configuring logging through `server.xml` can result in early log entries using a different log configuration from later ones. For this reason it is also possible to provide much of the logging configuration using `boostrap.properties` and in some cases using environment variables.

== Example logging configuration

Some common logging configuration examples are given in the following sections.

=== Managing log file storage


The `console.log` file is created by redirecting the process `stdout` and `stderr` to a file. As a result, Liberty is unable to offer the same level of management, like log rollover, as it offers for `messages.log`. If you are concerned about the increasing size of the `console.log` file, you can disable the `console.log` file and use the `messages.log` file instead. All the log messages sent to `console.log` are written to the `messages.log` file, and you can configure file rollover.

To disable the console log, and configure `messages.log` to roll over three times at 100Mb, use the following configuration:

[source,properties,linenums,role="code_column"]
----
com.ibm.ws.logging.max.file.size=100
com.ibm.ws.logging.max.files=3
com.ibm.ws.logging.console.log.level=OFF
com.ibm.ws.logging.copy.system.streams=false
----

=== JSON logging
When feeding log files into modern log aggregation and management tools it can be advantageous to have the log files stored using JSON format. This can be done in one of three ways:

* Using the `bootstrap.properties` file:
+
[source,properties,linenums,role="code_column"]
----
com.ibm.ws.logging.message.format=json
com.ibm.ws.logging.message.source=message,trace,accessLog,ffdc,audit
----
+
* Using environment variables:
+
[source,properties,linenums,role="code_column"]
----
WLP_LOGGING_MESSAGE_FORMAT=json
WLP_LOGGING_MESSAGE_SOURCE=message,trace,accessLog,ffdc,audit
----
+
* Using the `server.xml` file:
+
[source,xml,linenums,role="code_column"]
----
<logging messageFormat="json" messageSource="message,trace,accessLog,ffdc,audit" />
----
+
When using `server.xml` to configure json format some log lines are written in the default non-JSON format prior to `server.xml` startup which can cause issues with some tools. For example, https://stedolan.github.io/jq/[`jq`] would have trouble understanding the log files.

=== Configuring logging for a Docker image

It is common in Docker environments to disable `messages.log` and instead format the console output as JSON. This can be done using environment variables:

[source,properties,linenums,role="code_column"]
----
WLP_LOGGING_MESSAGE_FORMAT=json
WLP_LOGGING_MESSAGE_SOURCE=
WLP_LOGGING_CONSOLE_FORMAT=json
WLP_LOGGING_CONSOLE_LOGLEVEL=info
WLP_LOGGING_CONSOLE_SOURCE=message,trace,accessLog,ffdc,audit
----

This can be simply set when running the `docker run` command by using `-e` to set the envrionment variables:

[role='command']
```
docker run -e "WLP_LOGGING_CONSOLE_SOURCE=message,trace,accessLog,ffdc"
           -e "WLP_LOGGING_CONSOLE_FORMAT=json"
           -e "WLP_LOGGING_CONSOLE_LOGLEVEL=info"
           -e "WLP_LOGGING_MESSAGE_FORMAT=json"
           -e "WLP_LOGGING_MESSAGE_SOURCE=" open-liberty
```

=== Binary logging

Liberty has a high performance binary log format option that significantly reduces the overhead of writing trace files. Generally, when configuring binary logging, the `console.log` is disabled for best performance. This must be enabled using `bootstrap.properties`:

[source,properties,linenums,role="code_column"]
----
websphere.log.provider=binaryLogging-1.0
com.ibm.ws.logging.console.log.level=OFF
com.ibm.ws.logging.copy.system.streams=false
----

The `binaryLog` command line tool can be used to convert the binary log to a text file:

[role='command']
```
binaryLog view defaultServer
```

== Configuration settings by source

The table below shows the equivalent `server.xml`, `bootstrap.properties`, and environment variable configurations along with brief descriptions. Full configuration documentation is available in the config reference for the link:https://www.openliberty.io/docs/ref/config/#logging.html[logging] element.


|===
| Server XML Attribute|bootstrap property|Env var|Description

|hideMessage
|com.ibm.ws.logging.hideMessage
|
|You can use this attribute to configure the messages keys that you want to hide from the `console.log` and `messages.log` files. If the messages are configured to be hidden, then they are redirected to the `trace.log` file.

|logDirectory
|com.ibm.ws.logging.log.directory
|LOG_DIR
|You can use this attribute to set a directory for all log files, excluding the `console.log` file, but including FFDC. The default is `WLP_OUTPUT_DIR/serverName/logs`. It is not recommended to set the `logDirectory` in `server.xml` since it can result in some log data being written to the default location prior to `server.xml` being read.

4+|Console Log Config

|consoleFormat
|com.ibm.ws.logging.console.format
|WLP_LOGGING_CONSOLE_FORMAT
|The required format for the console. Valid values are `basic` or `json` format. By default, `consoleFormat` is set to `basic`.

|consoleLogLevel
|com.ibm.ws.logging.console.log.level
|WLP_LOGGING_CONSOLE_LOGLEVEL
|This filter controls the granularity of messages that go to the console. The valid values are INFO, AUDIT, WARNING, ERROR, and OFF. The default is AUDIT. If using with the Eclipse developer tools this must be set to the default.

|consoleSource
|com.ibm.ws.logging.console.source
|WLP_LOGGING_CONSOLE_SOURCE
|The list of comma-separated sources that route to the console. This property applies only when `consoleFormat="json"`. Valid values are `message`, `trace`, `accessLog`, `ffdc`, and `audit`. By default, `consoleSource` is set to `message`. To use the `audit` source, enable the Liberty link:https://www.openliberty.io/docs/ref/feature/#audit-1.0.html[audit-1.0] feature. To use the `accessLog` source you need to have configured link:https://www.openliberty.io/docs/ref/config/#httpAccessLogging.html[httpAccessLogging].

|copySystemStreams
|com.ibm.ws.logging.copy.system.streams
|
|If true, messages that are written to the System.out and System.err streams are copied to process `stdout` and `stderr` and so appear in `console.log`. If false, those messages are written to configured logs such as `messages.log` or `trace.log`, but they are not copied to `stdout` and `stderr` and do not appear in `console.log`. The default value is true.

4+|Message Log Config

|
|com.ibm.ws.logging.newLogsOnStart
|
|If set to true when Liberty starts, any existing `messages.log` or `trace.log` files are rolled over and logging writes to a new `messages.log` or `trace.log` file. If set to false `messages.log` or trace.log files only refresh when they hit the `maxFileSize`. The default is `true`. This setting cannot be provided using the `logging` element in `server.xml` because it is only processed during server bootstrap.

|isoDateFormat
|com.ibm.ws.logging.isoDateFormat
|
|Specifies whether to use ISO-8601 formatted dates in log files. The default value is false.

If set to true, the ISO-8601 format is used in the `messages.log` file, the `trace.log` file, and the FFDC logs. The format is `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.

If you specify a value of `false`, the date and time are formatted according to the default locale set in the system. If the default locale is not found, the format is `dd/MMM/yyyy HH:mm:ss:SSS z`.

|maxFiles
|com.ibm.ws.logging.max.files
|
|How many of each of the logs files are kept. This setting also applies to the number of exception summary logs for FFDC. So if this number is `10`, you might have 10 message logs, 10 trace logs, and 10 exception summaries in the `ffdc/` directory. By default, the value is `2`. The `console.log` does not roll so this setting does not apply.

|maxFileSize
|com.ibm.ws.logging.max.file.size
|
|The maximum size (in MB) that a log file can reach before it is rolled. Setting the value to `0` disables log rolling. The default value is `20`. The `console.log` does not roll so this setting does not apply.

|messageFileName
|com.ibm.ws.logging.message.file.name
|
|The message log has a default name of `messages.log`. This file always exists, and contains INFO and other (AUDIT, WARNING, ERROR, FAILURE) messages in addition to `System.out` and `System.err`. This log also contains time stamps and the issuing thread ID. If the log file is rolled over, the names of earlier log files have the format `messages_timestamp.log`

|messageFormat
|com.ibm.ws.logging.message.format
|WLP_LOGGING_MESSAGE_FORMAT
|The required format for the `messages.log` file. Valid values are `basic` or `json` format. By default, `messageFormat` is set to `basic`.

|messageSource
|com.ibm.ws.logging.message.source
|WLP_LOGGING_MESSAGE_SOURCE
|The list of comma-separated sources that route to the `messages.log` file. This property applies only when `messageFormat="json"`. Valid values are `message`, `trace`, `accessLog`, `ffdc`, and `audit`. By default, `messageSource` is set to `message`. To use the `audit` source, enable the Liberty link:https://www.openliberty.io/docs/ref/feature/#audit-1.0.html[audit-1.0] feature. To use the `accessLog` source you need to have configured link:https://www.openliberty.io/docs/ref/config/#httpAccessLogging.html[httpAccessLogging].

4+|Trace Config

|suppressSensitiveTrace
|
|
|The server trace can expose sensitive data when it traces untyped data, such as bytes received over a network connection. This attribute, when set to `true`, prevents potentially sensitive information from being exposed in log and trace files. The default value is `false`.

|traceFileName
|com.ibm.ws.logging.trace.file.name
|
|The `trace.log` file is only created if additional or detailed trace is enabled. `stdout` is recognized as a special value, and causes trace to be directed to the original standard out stream.

|traceFormat
|com.ibm.ws.logging.trace.format
|
|This attribute controls the format of the trace log. The default format for Liberty is `ENHANCED`. You can also use `BASIC` and `ADVANCED` formats.

|traceSpecification
|com.ibm.ws.logging.trace.specification
|
a|The trace string is used to selectively enable trace. The format of the log detail level specification:

component = level

where `component` specifies what log sources the `level` should be set to, and `level` specifies how much trace should be output using one of: `off`, `fatal`, `severe`, `warning`, `audit`, `info`, `config`, `detail`, `fine`, `finer`, `finest`, `all`. Multiple log detail level specifications can be provided by separating them with colons.

A component can be a logger name, trace group or class name. An asterisk pass:[*] acts as a wildcard to match multiple components based on a prefix. For example:

- `pass:[*]` Specifies all traceable code that is running in the application server, including the product system code and customer code.

- `com.ibm.ws.pass:[*]` Specifies all classes with the package name beginning with com.ibm.ws.

- `com.ibm.ws.classloading.AppClassLoader` Specifies the AppClassLoader class only.

|===

:leveloffset!:

:leveloffset: +1

// Module included in the following assemblies:
//
//

[id="testing-with-container-{context}"]
= Testing with a container


You can use MicroShed Testing to develop integration tests for your Open Liberty application. You test your application from outside its container so that the tests run against the same image that you use in production.


To write a test with MircoShed testing, first add `microshed-testing-testcontainers` and `junit-jupiter` artifact IDs as test-scoped dependencies, as shown in the following example:

[source,xml]
----
<dependency>
    <groupId>org.microshed</groupId>
    <artifactId>microshed-testing-testcontainers</artifactId>
    <version>0.4.1</version>
    <scope>test</scope>
</dependency>

<!-- Any compatible version of JUnit Jupiter 5.X will work -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.4.2</version>
    <scope>test</scope>
</dependency>
----

Next, create a test class with the  `MicroShedTest` annotation. Then, create a public `static MicroProfileApplication` method and inject one or more `public static JAX-RS` resources, as shown in the following example:

[source,xml]
----
@MicroShedTest
public class MyTest {

    @Container
    public static MicroProfileApplication app = new MicroProfileApplication()
                    .withAppContextRoot("/myservice");

    @Inject
    public static MyService mySvc;

    // write @Test methods as normal
----

In cases where a Dockerfile or container image is not available, use the link:https://github.com/MicroShed/microshed-testing/tree/master/sample-apps/liberty-app[`microshed-testing-liberty` adapter]. This adapter produces a container image that is similar to the following Dockerfile:

[source,xml]
----
FROM open-liberty:microProfile3
ADD build/libs/$APP_FILE /config/dropins
COPY src/main/liberty/config /config
----
For more information, see link:https://microshed.org/microshed-testing/[MicroShed Testing].

.Additional resources
* link:http://arquillian.org/modules/arquillian-liberty-managed-container-adapter/[Arquillian Liberty managed container adapter]

:leveloffset!:

:leveloffset: +1

:parent-context: {context}

[id="debugging-assembly-{context}"]
= Debugging
:context: debugging-assembly

:leveloffset: +1

// Module included in the following assemblies:
//<debugging-assembly>
//

[id="dev-mode-{context}"]
= Dev Mode


With Liberty dev mode, you can rapidly code, deploy, and debug applications with Liberty. You enable dev mode through the Liberty Maven-plugin.

To use dev mode, add the following code to your Maven pom.xml file and run the `mvn liberty:dev` command.


[source,xml]
----
<plugin>
    <groupId>io.openliberty.tools</groupId>
    <artifactId>liberty-maven-plugin</artifactId>
    <version>3.1.0</version>
</plugin>
----

Dev mode provides three key features:

- Your running server can detect, recompile, and pick up code changes.
- You can run unit and integration tests on demand, by pressing `Enter` in the command window where dev mode is running.
- You can attach a debugger to the running server to step through your code at any time.

When you use dev mode, Liberty automatically detects the following changes to your application source:

- Java source file changes and Java test file changes.
- Dependencies that are added to your pom.xml file. Liberty detects the dependencies and adds them to your class path.
- Resource file changes. Liberty detects them and copies them into your target directory.
- Configuration directory and configuration file changes. Liberty detects them and copies them into your target directory.
- Addition of new features in the Liberty server configuration. Liberty detects the new features, installs them, and starts them.

Dev Mode does not detect some changes. These changes include the following ones:

- The addition of a configuration directory or file.
- Changes to the host and port for Liberty.


If either of these changes are made, Liberty can detect them after you restart dev mode. To restart, first exit dev mode by typing `Control-C`, or by typing `q` and pressing `Enter`. Then, run the `mvn liberty:dev` command to restart.


For more information, see link:https://github.com/OpenLiberty/ci.maven/blob/master/docs/dev.md[Liberty Dev mode].

:leveloffset!:

:leveloffset: +1

// Module included in the following assemblies:
//
//

[id="managing-with-maven-{context}"]
= Managing build processes with the Open Liberty Maven plug-in

You can build and test your applications, whether they are simple applications with a single module or more complex applications that consist of multiple modules.

After you define the details and dependencies of a project, Maven automatically downloads and installs all of the dependencies. It also runs automated tests on an application after it is built. If the tests don’t pass after you update an application, the build fails. You must fix your code.

The following coordinates for the Maven plug-in are required:

[source,xml]
----
<groupId>io.openliberty.tools</groupId>
<artifactId>liberty-maven-plugin</artifactId>
<version>3.1.0</version>
----

To learn how to configure a simple web servlet application by using Maven and the Liberty Maven plug-in, see link:https://openliberty.io/guides/maven-intro.html[Building a web application with Maven].

Jakarta EE applications consist of multiple modules that work together as one entity. To learn how to build an application with multiple modules by using Maven and Open Liberty, see link:https://openliberty.io/guides/maven-multimodules.html[Creating a multi-module application].

:leveloffset!:

:leveloffset: +1

// Module included in the following assemblies:
//
// <debugging-assembly>

[id="tracing-requests-{context}"]
= Tracing Requests

Distributed tracing helps you troubleshoot microservices by examining and logging requests as they propagate through a distributed system, allowing developers to tackle the otherwise difficult task of debugging these requests. Without a distributed tracing system in place, it's difficult to analyze workflows and pinpoint when and by whom a request is received or when a response is returned.

To learn how to monitor and trace logging requests across microservices in an application, see link:https://www.openliberty.io/guides/microprofile-opentracing.html[Enabling distributed tracing in microservices].

:leveloffset!:

:context: {parent-context}

:leveloffset!:

:leveloffset: +1

:parent-context: {context}

[id="monitoring-assembly-{context}"]
= Monitoring Open Liberty
:context: monitoring-assembly

You can use MicroProfile Metrics and MicroProfile Health to monitor microservices and applications that run on Open Liberty. Enabling and reporting metric and health check data for your microservices helps you pinpoint issues, collect data for capacity planning, and decide when to scale a service up or down.

:leveloffset: +1

// Module included in the following assemblies:
//
// <monitoring-assembly>

[id="enabling-monitoring-microservices-{context}"]
= Enabling monitoring in microservices

Building observability into microservices externalizes the internal status of a system to enable operations teams to monitor microservice systems more effectively. It's important that microservices are written to produce metrics that can be used by operations teams when the microservices are running in production.

Metrics are emitted from a number of different places. You can obtain them from applications, the Open Liberty runtime, and the Java virtual machine (JVM). link:https://github.com/eclipse/microprofile-metrics#eclipse-microprofile-metrics[MicroProfile Metrics] provides a `/metrics` endpoint from which you can access all metrics that are emitted by the Open Liberty server and deployed applications. They can be gathered and stored in database tools, such as Prometheus, and displayed on dashboards, such as Grafana.

Metrics come in various forms, including counters, gauges, timers, histograms, and meters. You can enable metrics in your Open Liberty application with the MicroProfile Metrics feature, which defines annotations that help you quickly build metrics into your code.

For a list of all available Open Liberty metrics, see the link:https://openliberty.io/docs/ref/general/#metrics-catalog.html[metrics reference list].

To learn how to use MicroProfile Metrics to enable and provide metrics from a microservice, see link:https://openliberty.io/guides/microprofile-metrics.html[Providing metrics from a microservice].

.Additional Resources
* link:https://openliberty.io/docs/ref/general/#microservice_observability_metrics.html[Microservice observability with metrics]

:leveloffset!:

:leveloffset: +1

// Module included in the following assemblies:
//
// <monitoring-assembly>

[id="enabling-health-checks{context}"]
= Enabling health checks in microservices

A health check is a special REST API that you can use to validate the status of a microservice and its dependencies. link:https://github.com/eclipse/microprofile-health[MicroProfile Health] enables services in an application to self-check their health and then publishes the overall health status to a defined endpoint.

A self-check can be used to assess anything that the service needs, such as:

- Dependencies

- System properties

- Database connections

- Endpoint connections

- Resource availability

With MicroProfile Health, you can enable the services in your liberty application to self-check for liveness and readiness. A liveness check determines whether a service encountered a bug or deadlock. If this check fails, the service is not running and can be terminated. This check corresponds to the Kubernetes liveness probe, which automatically restarts the pod if the check fails. A readiness check determines whether a service is ready to process requests. This check corresponds to the readiness probe in Kubernetes.

To learn how to use MicroProfile Health to enable and report microservice health checks, see link:https://openliberty.io/guides/microprofile-health.html[Adding health reports to microservices].

.Additional resources
* link:https://www.openliberty.io/docs/ref/general/#health-check-microservices.html[Enabling health checking of microservices]

:leveloffset!:

:context: {parent-context}

:leveloffset!:

[appendix]
:leveloffset: +1

// Module included in the following assemblies:
//
//

[id="additional-open-liberty-resources-{context}"]
= Additional Open Liberty resources

You can learn more about Open Liberty and the APIs it supports by viewing resources on the Open Liberty website.

* link:https://openliberty.io/docs/ref/command/[Open Liberty server commands]
* link:https://openliberty.io/guides/[Open Liberty guides]
* link:https://openliberty.io/docs/ref/javaee/[Java EE API]
* link:https://openliberty.io/docs/ref/microprofile/[MicroProfile API]

:leveloffset!:
